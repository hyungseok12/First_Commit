"""
## 문제
https://leetcode.com/problems/special-binary-string/

## 문제 재정의
- 내 말로 정리: 
  처음에 문제 읽고 뭔소린가 했는데, 결국 괄호 문제랑 똑같음
  1을 여는괄호, 0을 닫는괄호로 생각하면 됨
  ex) "1100" = "(())", "1010" = "()()"
  연속된 특수 문자열 두개를 swap해서 사전순 가장 큰거 만들면 됨
  
- 입력: 특수 이진 문자열 s (길이 최대 50)
- 출력: 사전순으로 제일 큰 문자열
- 제약: 입력은 무조건 유효한 특수 이진 문자열임

## 수도코드
1. 1 나오면 +1, 0 나오면 -1 해서 카운트
2. 카운트가 0 되면 그게 하나의 덩어리(특수 문자열)
3. 각 덩어리 안쪽을 재귀로 똑같이 처리
4. 모은 덩어리들 내림차순 정렬해서 붙이면 끝

## 프롬프트
> 특수 이진 문자열 문제인데, 괄호 문제로 변환해서 풀려고 해.
> 1을 '(', 0을 ')'로 보고, 카운트가 0이 되면 하나의 덩어리로 분리한 다음
> 각 덩어리 안쪽은 재귀로 처리하고, 마지막에 내림차순 정렬해서 붙이면 될 것 같아.
> 이 로직대로 파이썬 코드 짜줘.

## 최종 코드
밑에 있음

## 회고
- 배운 점: 
  괄호 문제로 변환해서 생각하니까 훨씬 이해하기 쉬웠음
  재귀 쓰면 안쪽도 알아서 정렬되니까 편함
  근데 처음에 왜 정렬하면 되는지 이해 안됐는데
  1이 앞에 많을수록 사전순으로 크니까 큰거부터 붙이면 됨
"""


class Solution:

    def makeLargestSpecial(self, s: str) -> str:
        if not s:
            return s

        parts = []
        cnt = 0
        start = 0

        for i, c in enumerate(s):
            cnt += 1 if c == '1' else -1

            # cnt가 0이면 하나의 덩어리 완성
            if cnt == 0:
                # 안쪽 재귀 돌림 (맨앞 1이랑 맨뒤 0 빼고)
                inside = self.makeLargestSpecial(s[start + 1:i])
                parts.append('1' + inside + '0')
                start = i + 1

        # 큰거부터 정렬
        parts.sort(reverse=True)

        return ''.join(parts)
